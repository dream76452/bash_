if [ $name = Adam ]; then
	echo ok
else
	echo fuck
fi

[ $name = $username ]
-ne !=
-lt <
-le <=
-gt >
-ge >=
!
-a and
-o or
|| command=1 echo error
&& command=1 echo error
firefox & in background mode
command && echo true || echo false
echo "88.8 < 77.8" | bc -l
# 0
echo $((2+2))
if variable dont exist you should "$variable"

loop:
for file in *.txt;do
        echo in progress $file
        cp $file chery
done

func:
greet(){
	echo Hello $1
}
greet vivi

arg console:
echo first arg $1
echo all arg $@
#run ./backup a b

if [ -f "file.txt" ];then
	cat file.txt
else
	echo Error
fi

DATE=$(date +%Y%m%d_%H%M)

$? last command 0 succesfull and 1,2,3...

#!/bin/bash

case $1 in
        vivi | administrator)
                echo Hello
                ;;
        hel)
                echo lol
                ;;
        *)
                echo fuck
                ;;
esac

for i in $list;do echo -n $i | wc -c; done

showuptime(){
        up=$(uptime -p | cut -c4-)
        since=$(uptime -s)
        cat <<EOF
----
This machine has been up for $up
It has been running since $since
----
EOF
}
showuptime

showname(){
        echo hello $1
        if [ $1 = vivi ];then
                return 0
        else
                return 1
        fi
}
showname $1
if [ $? = 1 ];then
        echo fuck
fi

awk '{print $1}' zoro.txt
awk -F, '{print $2}' zoro.txt
echo lol, lol | awk -F, '{print $2}' | cut -c2
l
-c2-lol
awk -F, '{print $3}' nami.txt | cut -c2
sed [опции] 'команда' файл
sed 's/что_ищем/на_что_меняем/(g=all)' файл
s=substitute
sed '/empty str/d' sedtest.txt
sed '2d' file or '1,2d'
a\ append
i\ insert
c\ cut
sed '2i\lol'
sed '/hello/a\warning' sedtest.txt
sed -i.ORIGINAL 's/boy/black/g' sedtest.txt
sed -i 's/[0-9]\+/number/g' sedtest.txt
sed '/^$/d' sedtest.txt
echo $RANDOM 0-32767
read name
export variable
sleep 3
vim ~/.bashrc
export twitter="Elon Musk"
source ~/.bashrc
echo $((2+3))
r=$((($RANDOM%20)+$age))
16384

sudo su -
read -p = enter
x=1
while [ $x -le 10 ]
do
        read -p "Press enter if pushups = $x"
        (( x++ ))
done
echo task complete

x=1
while read -r line; do
echo "Line $x $line"
(( x ++ ))
done < bash_scripts

true


until [ $order == "coffee" ]
do
        echo "Would you like coffee or tea?"
        read order
done
echo "Excellent choice, here is your choice."

range 
for i in {1..10};
do 
	echo $i
done

about ping
ping google.com
icmp_seq — номер пакета
ttl — время жизни пакета (сколько хостов он может пройти)
time — время отклика в миллисекундах (ms)
-c N share N packet
-i interval
&>/dev/null скрывает вывод
for x in youtube.com google.com bing.com facebook.com networkchuck.com;
do
        if ping -q -c 2 -W 1 $x > /dev/null;then
       #!/bin/bash

file="processing.log"

max_duration=0
longest_video=""

for video in $(grep "Начал обработку" "$file" | awk '{print $6}' | sort -u); do
    # Находим время начала
    start_time=$(grep "Начал обработку $video" "$file" | awk '{print $1,$2}')
    
    # Находим время окончания
    end_time=$(grep "Завершено: $video" "$file" | awk '{print $1,$2}')
    
    # Проверяем, что оба времени найдены
    if [ -z "$start_time" ] || [ -z "$end_time" ]; then
        continue
    fi
    
    # Преобразуем в секунды
    start=$(date -d "$start_time" +%s)
    end=$(date -d "$end_time" +%s)
    
    # Длительность
    duration=$((end - start))
    
    # Сравниваем
    if [ $duration -gt $max_duration ]; then
        max_duration=$duration
        longest_video=$video
    fi
done

# Выводим результат
if [ -n "$longest_video" ]; then
    echo "$longest_video $max_duration"
else
    echo "Видео не найдено или не обработано"
fi         echo "$x is up"
        else
                echo $x is down
        fi
done

for x in $(cat cities.txt);
do
        weather=$(curl -s http://wttr.in/$x?format=3)
        echo "The weather for $weather"
done
echo "What do you want to check?"
read target
while true
do
        if ping -q -c 2 -W 1 $target > /dev/null; then
                echo "Hey, you're up!!"
                break
        else
                echo "$target is currently down."
        fi
sleep 2
done

echo floors
for i in {1..17};
do
        if [ $i = 14 ];then
                continue

        fi
        echo floor $i
        sleep 2
done

echo $(date)

find /var/log -name "*.log" | wc -l

df -h - use disk data
du -sh /* 2>/dev/null | sort -hr | head -10
du -sh /*
du = disk usage  — показывает, сколько места занимают файлы/папки.
-s = summarize  — только общее значение, без деталей.
-h = human-readable  — в мегабайтах (M), гигабайтах (G) и т.д.
/* = все элементы в корневой директории (/bin, /home, /etc, /var и т.д.)

| sort -hr 

    | — передаёт результат du на вход sort.
    sort -h — сортировка в человеческом формате  (2G > 100M).
    -r — по убыванию  (от большего к меньшему).
     

    Без -h сортировка была бы лексикографической: 10G, 2G, 500M → неправильно.

| head -10 

    Показывает первые 10 строк  — то есть 10 самых больших папок .
htop
nproc - count of core
Load average  — это средняя нагрузка системы  за определённое время. Она показывает, сколько процессов в среднем находилось в состоянии "работает или ждёт CPU" .
load average: 1.25, 0.80, 0.45
< 1.00  — система работает в норме
= 1.00  — CPU полностью загружен, но справляется
> 1.00  — процессы ждут CPU , возможна перегрузка

usage=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
df / - disk usage
tail -1 - 2 str 

usage_cpu=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%//')
top -bn1 - for scripts
-b - for text output
-n1 - make one loop


filename="example.txt"
newname="${filename%.txt}.processed.txt"

# Получаем текущую дату
timestamp=$(date "+%Y-%m-%d %H:%M")

# Ищем все .txt файлы
find . -type f -name "*.txt" | while read filepath; do
    # Извлекаем имя файла (с путём)
    filename=$(basename "$filepath")
    dirname=$(dirname "$filepath")

    # Формируем новое имя
    newname="${filename%.txt}.processed.txt"
    newpath="$dirname/$newname"

    # Добавляем строку в начало файла
    sed -i "1i\Этот файл обработан: $timestamp" "$filepath"

    # Переименовываем файл
    mv "$filepath" "$newpath"

    # Выводим статус
    echo "Обработано: $filename → $newname"
done

wget:
wget -O name_file - save how name
-c -  continue not stop downloading
-q - without output progress
-nv - only problems

$? code last command 0=true

echo $(basename "$SHELL")

file=app.log
grep 2025-04-05 $file
grep 2025-04-06 $file
echo Morning:
awk '$2 ~ /^08:/ || $2 ~ /^09:/' $file
echo successfull:
grep "Успех" $file | wc -l
grep "ERROR" $file | awk '{print $1,$2}'
echo modified: > summary.txt
grep "Обработка" $file | wc -l >> summary.txt
echo "Count of error:" >>summary.txt
grep "ERROR" $file | wc -l >> summary.txt
early=$(grep 'Скрипт запущен' $file | sort | head -1 | awk '{print $1,$2}')
late=$(grep 'Скрипт запущен' $file | sort | tail -1 | awk '{print $1,$2}')
echo early: $early >> summary.txt
echo late: $late >> summary.txt

date -d "2025-04-05 10:00:01" +%s - time start since start epoch
%s     seconds since the Epoch (1970-01-01 00:00 UTC)

